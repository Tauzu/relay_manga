<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ãƒãƒ³ã‚¬ã‚’ãˆãŒã</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { 
            overflow: hidden;
            margin: 0;
            padding: 0;
            touch-action: pan-x pan-y pinch-zoom;
        }
        .editor-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            background: #f5f5f5;
            touch-action: pan-x pan-y pinch-zoom;
        }
        
        .toolbar {
            background: white;
            border-bottom: 2px solid #ddd;
            padding: 0.75rem;
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
            flex-shrink: 0;
        }
        
        .tool-section {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            padding: 0.25rem 0.5rem;
            border-right: 1px solid #ddd;
        }
        
        .tool-section:last-child { border-right: none; }
        
        .tool-btn {
            padding: 0.5rem 0.75rem;
            border: 1px solid #ccc;
            background: white;
            cursor: pointer;
            border-radius: 0.25rem;
            transition: all 0.2s;
            white-space: nowrap;
        }
        
        .tool-btn:hover { background: #f0f0f0; }
        .tool-btn.active {
            background: #3b82f6;
            color: white;
            border-color: #2563eb;
        }
        
        .tool-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .btn-primary {
            background: #3b82f6;
            color: white;
            border-color: #2563eb;
        }
        
        .btn-primary:hover {
            background: #2563eb;
        }
        
        .btn-success {
            background: #10b981;
            color: white;
            border-color: #059669;
        }
        
        .btn-success:hover {
            background: #059669;
        }
        
        .spacer {
            flex: 1;
        }
        
        .canvas-wrapper {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 1rem;
            overflow: auto;
            min-height: 0;
            touch-action: pan-x pan-y pinch-zoom;
        }
        
        #manga-canvas {
            background: white;
            border: 2px solid #333;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            cursor: crosshair;
            max-width: 100%;
            max-height: 100%;
            height: auto;
            width: auto;
            touch-action: auto;
        }
        
        .text-input-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        
        .text-input-box {
            background: white;
            padding: 2rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }
        
        @media (max-width: 640px) {
            .toolbar { padding: 0.5rem; gap: 0.5rem; }
            .tool-btn { padding: 0.4rem 0.6rem; font-size: 0.875rem; }
            .canvas-wrapper { padding: 0.5rem; }
        }
    </style>
</head>
<body>

<div class="editor-container">
    <!-- ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ -->
    <div class="toolbar">
        <!-- ã‚¹ãƒ†ãƒƒãƒ—1: ã‚³ãƒå‰²ã‚Šé¸æŠ -->
        <div class="tool-section" id="step1-section">
            <label class="font-semibold">ã‚³ãƒå‰²ã‚Š:</label>
            <select id="panel-rows" class="border rounded px-2 py-1">
                <option value="1" selected>1æ®µ</option>
                <option value="2">2æ®µ</option>
                <option value="3">3æ®µ</option>
            </select>
            <span>Ã—</span>
            <select id="panel-cols" class="border rounded px-2 py-1">
                <option value="1" selected>1åˆ—</option>
                <option value="2">2åˆ—</option>
                <option value="3">3åˆ—</option>
            </select>
            <button id="apply-panels" class="tool-btn btn-primary">æ±ºå®š</button>
        </div>
        
        <!-- ã‚¹ãƒ†ãƒƒãƒ—2: æç”»ãƒ„ãƒ¼ãƒ« -->
        <div class="tool-section" id="step2-section" style="display: none;">
            <button id="tool-pencil" class="tool-btn active">âœï¸ é‰›ç­†</button>
            <button id="tool-eraser" class="tool-btn">ğŸ§¹ æ¶ˆã—ã‚´ãƒ </button>
            <button id="tool-text" class="tool-btn">ğŸ“ ãƒ†ã‚­ã‚¹ãƒˆ</button>
        </div>
        
        <div class="tool-section" id="brush-size-section" style="display: none;">
            <label class="text-sm">å¤ªã•:</label>
            <input id="brush-size" type="range" min="1" max="20" value="3" class="w-20">
            <span id="brush-size-value" class="text-sm">3</span>
        </div>
        
        <div class="tool-section" id="history-section" style="display: none;">
            <button id="undo-btn" class="tool-btn" disabled>â†¶ Undo</button>
            <button id="redo-btn" class="tool-btn" disabled>â†· Redo</button>
        </div>
        
        <div class="tool-section" id="action-section" style="display: none;">
            <button id="clear-canvas" class="tool-btn">ğŸ—‘ï¸ ã‚¯ãƒªã‚¢</button>
            <button id="save-image" class="tool-btn btn-success">âœ… å®Œæˆ</button>
        </div>
        
        <!-- ã‚¹ãƒšãƒ¼ã‚µãƒ¼ -->
        <div class="spacer"></div>
        
        <div class="tool-section">
            <button id="back-btn" class="tool-btn">â† æˆ»ã‚‹</button>
        </div>
    </div>
    
    <!-- ã‚­ãƒ£ãƒ³ãƒã‚¹ -->
    <div class="canvas-wrapper">
        <canvas id="manga-canvas" width="800" height="800"></canvas>
    </div>
</div>

<!-- ãƒ†ã‚­ã‚¹ãƒˆå…¥åŠ›ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ -->
<div id="text-input-overlay" class="text-input-overlay">
    <div class="text-input-box">
        <h3 class="text-lg font-bold mb-3">ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›</h3>
        <textarea id="text-content" class="w-full border rounded p-2 mb-3" rows="3" 
                  placeholder="ã‚»ãƒªãƒ•ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„"></textarea>
        <div class="flex gap-2 justify-end">
            <button id="text-cancel" class="px-4 py-2 border rounded">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
            <button id="text-ok" class="px-4 py-2 bg-blue-500 text-white rounded">OK</button>
        </div>
    </div>
</div>

<script>
const canvas = document.getElementById('manga-canvas');
const ctx = canvas.getContext('2d');
let isDrawing = false;
let currentTool = 'pencil';
let brushSize = 3;
let panelsApplied = false;

// Undo/Redoç”¨ã®å±¥æ­´
let history = [];
let historyStep = -1;

// åˆæœŸåŒ–: ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ç™½ã§å¡—ã‚Šã¤ã¶ã—
ctx.fillStyle = 'white';
ctx.fillRect(0, 0, canvas.width, canvas.height);

// URLãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã§å†ç·¨é›†ãƒ¢ãƒ¼ãƒ‰ã‹ã©ã†ã‹ã‚’åˆ¤å®š
const urlParams = new URLSearchParams(window.location.search);
const isEditMode = urlParams.has('edit');

// æ—¢å­˜ã®çµµãŒã‚ã‚‹å ´åˆã§ã€ã‹ã¤å†ç·¨é›†ãƒ¢ãƒ¼ãƒ‰ã®å ´åˆã®ã¿èª­ã¿è¾¼ã‚€
const savedDrawing = sessionStorage.getItem('mangaDrawing');
if (savedDrawing && isEditMode) {
    const img = new Image();
    img.onload = () => {
        ctx.drawImage(img, 0, 0);
        // ã‚³ãƒå‰²ã‚ŠãŒé©ç”¨ã•ã‚ŒãŸçŠ¶æ…‹ã¨ã—ã¦æ‰±ã†
        panelsApplied = true;
        document.getElementById('step1-section').style.display = 'none';
        document.getElementById('step2-section').style.display = 'flex';
        document.getElementById('brush-size-section').style.display = 'flex';
        document.getElementById('history-section').style.display = 'flex';
        document.getElementById('action-section').style.display = 'flex';
        // åˆæœŸçŠ¶æ…‹ã‚’å±¥æ­´ã«ä¿å­˜
        saveState();
    };
    img.src = savedDrawing;
} else {
    // æ–°è¦ä½œæˆã®å ´åˆã¯sessionStorageã‚’ã‚¯ãƒªã‚¢ã—ã¦åˆæœŸãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼è¡¨ç¤º
    if (!isEditMode) {
        sessionStorage.removeItem('mangaDrawing');
    }
    updatePanelPreview();
}

// å±¥æ­´ã‚’ä¿å­˜
function saveState() {
    historyStep++;
    if (historyStep < history.length) {
        history.length = historyStep;
    }
    history.push(canvas.toDataURL());
    updateHistoryButtons();
}

// å±¥æ­´ãƒœã‚¿ãƒ³ã®æœ‰åŠ¹/ç„¡åŠ¹ã‚’æ›´æ–°
function updateHistoryButtons() {
    document.getElementById('undo-btn').disabled = historyStep <= 0;
    document.getElementById('redo-btn').disabled = historyStep >= history.length - 1;
}

// Undo
document.getElementById('undo-btn').addEventListener('click', () => {
    if (historyStep > 0) {
        historyStep--;
        const img = new Image();
        img.onload = () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0);
            updateHistoryButtons();
        };
        img.src = history[historyStep];
    }
});

// Redo
document.getElementById('redo-btn').addEventListener('click', () => {
    if (historyStep < history.length - 1) {
        historyStep++;
        const img = new Image();
        img.onload = () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0);
            updateHistoryButtons();
        };
        img.src = history[historyStep];
    }
});

// ã‚³ãƒå‰²ã‚Šãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼ˆæ®µæ•°ãƒ»åˆ—æ•°å¤‰æ›´æ™‚ï¼‰
function updatePanelPreview() {
    const rows = parseInt(document.getElementById('panel-rows').value);
    const cols = parseInt(document.getElementById('panel-cols').value);
    
    // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚¯ãƒªã‚¢
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // ã‚³ãƒå‰²ã‚Šç·šã‚’æç”»ï¼ˆä½™ç™½ã‚’è¿½åŠ ï¼‰
    const margin = 20;
    const usableWidth = canvas.width - (margin * (cols + 1));
    const usableHeight = canvas.height - (margin * (rows + 1));
    const panelWidth = usableWidth / cols;
    const panelHeight = usableHeight / rows;
    
    ctx.strokeStyle = '#ccc';
    ctx.lineWidth = 2;
    
    // ã‚³ãƒã®æ ã‚’æç”»ï¼ˆãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã¯è–„ã„ã‚°ãƒ¬ãƒ¼ï¼‰
    for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
            const x = margin + col * (panelWidth + margin);
            const y = margin + row * (panelHeight + margin);
            
            ctx.strokeRect(x, y, panelWidth, panelHeight);
        }
    }
}

// æ®µæ•°ãƒ»åˆ—æ•°å¤‰æ›´æ™‚ã«ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æ›´æ–°
document.getElementById('panel-rows').addEventListener('change', updatePanelPreview);
document.getElementById('panel-cols').addEventListener('change', updatePanelPreview);

// ãƒ„ãƒ¼ãƒ«åˆ‡ã‚Šæ›¿ãˆ
document.getElementById('tool-pencil').addEventListener('click', () => {
    currentTool = 'pencil';
    updateToolButtons();
});

document.getElementById('tool-eraser').addEventListener('click', () => {
    currentTool = 'eraser';
    updateToolButtons();
});

document.getElementById('tool-text').addEventListener('click', () => {
    currentTool = 'text';
    updateToolButtons();
});

function updateToolButtons() {
    document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
    if (currentTool === 'pencil') document.getElementById('tool-pencil').classList.add('active');
    if (currentTool === 'eraser') document.getElementById('tool-eraser').classList.add('active');
    if (currentTool === 'text') document.getElementById('tool-text').classList.add('active');
}

// ãƒ–ãƒ©ã‚·ã‚µã‚¤ã‚º
const brushSizeInput = document.getElementById('brush-size');
const brushSizeValue = document.getElementById('brush-size-value');
brushSizeInput.addEventListener('input', (e) => {
    brushSize = parseInt(e.target.value);
    brushSizeValue.textContent = brushSize;
});

// ã‚³ãƒå‰²ã‚Šé©ç”¨
document.getElementById('apply-panels').addEventListener('click', () => {
    const rows = parseInt(document.getElementById('panel-rows').value);
    const cols = parseInt(document.getElementById('panel-cols').value);
    
    // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚¯ãƒªã‚¢
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // ã‚³ãƒå‰²ã‚Šç·šã‚’æç”»ï¼ˆä½™ç™½ã‚’è¿½åŠ ï¼‰
    const margin = 20;
    const usableWidth = canvas.width - (margin * (cols + 1));
    const usableHeight = canvas.height - (margin * (rows + 1));
    const panelWidth = usableWidth / cols;
    const panelHeight = usableHeight / rows;
    
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 3;
    
    // ã‚³ãƒã®æ ã‚’æç”»
    for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
            const x = margin + col * (panelWidth + margin);
            const y = margin + row * (panelHeight + margin);
            
            ctx.strokeRect(x, y, panelWidth, panelHeight);
        }
    }
    
    // åˆæœŸçŠ¶æ…‹ã‚’å±¥æ­´ã«ä¿å­˜
    saveState();
    
    panelsApplied = true;
    
    // ã‚¹ãƒ†ãƒƒãƒ—2ã®ãƒ„ãƒ¼ãƒ«ã‚’è¡¨ç¤º
    document.getElementById('step1-section').style.display = 'none';
    document.getElementById('step2-section').style.display = 'flex';
    document.getElementById('brush-size-section').style.display = 'flex';
    document.getElementById('history-section').style.display = 'flex';
    document.getElementById('action-section').style.display = 'flex';
});

// æç”»å‡¦ç†
let lastX = 0;
let lastY = 0;

canvas.addEventListener('mousedown', startDrawing);
canvas.addEventListener('mousemove', draw);
canvas.addEventListener('mouseup', stopDrawing);
canvas.addEventListener('mouseout', stopDrawing);

canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
canvas.addEventListener('touchend', handleTouchEnd, { passive: false });

// ã‚¿ãƒƒãƒæ“ä½œç”¨ã®å¤‰æ•°
let touches = [];

function handleTouchStart(e) {
    if (!panelsApplied) return;
    
    // 2æœ¬æŒ‡ä»¥ä¸Š = ã‚ºãƒ¼ãƒ /ãƒ‘ãƒ³æ“ä½œï¼ˆãƒ–ãƒ©ã‚¦ã‚¶ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå‹•ä½œã‚’è¨±å¯ï¼‰
    if (e.touches.length >= 2) {
        // ä½•ã‚‚ã›ãšã€ãƒ–ãƒ©ã‚¦ã‚¶ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå‹•ä½œã‚’è¨±å¯
        return;
    }
    
    // 1æœ¬æŒ‡ = æç”»
    if (e.touches.length === 1) {
        if (currentTool === 'text') {
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousedown', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            showTextInput(mouseEvent);
            e.preventDefault();
            return;
        }
        
        e.preventDefault();
        const touch = e.touches[0];
        const mouseEvent = new MouseEvent('mousedown', {
            clientX: touch.clientX,
            clientY: touch.clientY
        });
        canvas.dispatchEvent(mouseEvent);
    }
}

function handleTouchMove(e) {
    // 2æœ¬æŒ‡ä»¥ä¸Š = ã‚ºãƒ¼ãƒ /ãƒ‘ãƒ³æ“ä½œï¼ˆãƒ–ãƒ©ã‚¦ã‚¶ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå‹•ä½œã‚’è¨±å¯ï¼‰
    if (e.touches.length >= 2) {
        return;
    }
    
    // 1æœ¬æŒ‡ = æç”»
    if (e.touches.length === 1 && isDrawing) {
        e.preventDefault();
        const touch = e.touches[0];
        const mouseEvent = new MouseEvent('mousemove', {
            clientX: touch.clientX,
            clientY: touch.clientY
        });
        canvas.dispatchEvent(mouseEvent);
    }
}

function handleTouchEnd(e) {
    if (e.touches.length === 0) {
        const mouseEvent = new MouseEvent('mouseup', {});
        canvas.dispatchEvent(mouseEvent);
    }
}

function startDrawing(e) {
    if (!panelsApplied) return;
    
    if (currentTool === 'text') {
        showTextInput(e);
        return;
    }
    
    isDrawing = true;
    const pos = getMousePos(e);
    lastX = pos.x;
    lastY = pos.y;
}

function draw(e) {
    if (!isDrawing) return;
    
    e.preventDefault();
    
    const pos = getMousePos(e);
    
    ctx.beginPath();
    ctx.moveTo(lastX, lastY);
    ctx.lineTo(pos.x, pos.y);
    
    if (currentTool === 'pencil') {
        ctx.strokeStyle = '#000';
        ctx.lineWidth = brushSize;
    } else if (currentTool === 'eraser') {
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = brushSize * 2;
    }
    
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.stroke();
    
    lastX = pos.x;
    lastY = pos.y;
}

function stopDrawing() {
    if (isDrawing) {
        isDrawing = false;
        saveState();
    }
}

function getMousePos(e) {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    
    return {
        x: (e.clientX - rect.left) * scaleX,
        y: (e.clientY - rect.top) * scaleY
    };
}

// ãƒ†ã‚­ã‚¹ãƒˆå…¥åŠ›
let textClickPos = null;

function showTextInput(e) {
    textClickPos = getMousePos(e);
    document.getElementById('text-input-overlay').style.display = 'flex';
    document.getElementById('text-content').focus();
}

document.getElementById('text-ok').addEventListener('click', () => {
    const text = document.getElementById('text-content').value.trim();
    if (text && textClickPos) {
        ctx.fillStyle = '#000';
        ctx.font = '20px sans-serif';
        ctx.fillText(text, textClickPos.x, textClickPos.y);
        saveState();
    }
    closeTextInput();
});

document.getElementById('text-cancel').addEventListener('click', closeTextInput);

function closeTextInput() {
    document.getElementById('text-input-overlay').style.display = 'none';
    document.getElementById('text-content').value = '';
    textClickPos = null;
}

// ã‚¯ãƒªã‚¢
document.getElementById('clear-canvas').addEventListener('click', () => {
    if (confirm('æœ¬å½“ã«ã‚¯ãƒªã‚¢ã—ã¾ã™ã‹ï¼Ÿ')) {
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        history = [];
        historyStep = -1;
        updatePanelPreview();
        panelsApplied = false;
        document.getElementById('step1-section').style.display = 'flex';
        document.getElementById('step2-section').style.display = 'none';
        document.getElementById('brush-size-section').style.display = 'none';
        document.getElementById('history-section').style.display = 'none';
        document.getElementById('action-section').style.display = 'none';
    }
});

// ä¿å­˜
document.getElementById('save-image').addEventListener('click', () => {
    canvas.toBlob((blob) => {
        const reader = new FileReader();
        reader.onloadend = () => {
            sessionStorage.setItem('mangaDrawing', reader.result);
            {% if parent %}
                window.location.href = "{% url 'continue_page' parent.id %}?edit=1";
            {% else %}
                window.location.href = "{% url 'create_page' manga.id %}?edit=1";
            {% endif %}
        };
        reader.readAsDataURL(blob);
    });
});

// æˆ»ã‚‹ãƒœã‚¿ãƒ³
document.getElementById('back-btn').addEventListener('click', () => {
    if (confirm('æœ¬å½“ã«æˆ»ã‚Šã¾ã™ã‹ï¼Ÿç¾åœ¨ã®å†…å®¹ã¯ç ´æ£„ã•ã‚Œã¾ã™ã€‚')) {
        {% if parent %}
            window.location.href = "{% url 'continue_page' parent.id %}";
        {% else %}
            window.location.href = "{% url 'create_page' manga.id %}";
        {% endif %}
    }
});
</script>
</body>
</html>